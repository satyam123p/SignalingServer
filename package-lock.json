import React, { useRef, useState, useEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  Alert,
} from 'react-native';
import {
  RTCPeerConnection,
  RTCIceCandidate,
  RTCSessionDescription,
  setLocalDescription,
  setRemoteDescription
} from 'react-native-webrtc';

const type = {
  ROOM_CREATE: {
    RESPONSE_FAILURE: 'CHECK_ROOM_RESPONSE_FAILURE',
    RESPONSE_SUCCESS: 'CHECK_ROOM_RESPONSE_SUCCESS',
  },
  ROOM_DESTROY: {
    RESPONSE_FAILURE: 'DESTROY_ROOM_RESPONSE_FAILURE',
    RESPONSE_SUCCESS: 'DESTORY_ROOM_RESPONSE_SUCCESS',
  },
  ROOM_JOIN: {
    RESPONSE_FAILURE: 'JOIN_ROOM_RESPONSE_FAILURE',
    RESPONSE_SUCCESS: 'JOIN_ROOM_RESPONSE_SUCCESS',
    REQUEST: 'JOIN_ROOM_REQUEST',
    NOTIFY: 'JOIN_ROOM_NOTIFY',
  },
  ROOM_EXIT: {
    REQUEST: 'EXIT_ROOM_REQUEST',
    NOTIFY: 'EXIT_ROOM_NOTIFY',
  },
  ROOM_DISONNECTION: {
    NOTIFY: 'DISCONNECT_ROOM_NOTIFICATION',
  },
  WEB_RTC: {
    OFFER: 'OFFER',
    ANSWER: 'ANSWER',
    ICE_CANDIDATES: 'ICE_CANDIDATES',
  },
};

const labels = {
  NORMAL_SERVER_PROCESS: 'NORMAL_SERVER_PROCESS',
  WEBRTC_PROCESS: 'WEBRTC_PROCESS',
};

const webRTCConfiguratons = {
  iceServers: [
    {
      urls: [
        'stun:stun.l.google.com:19302',
        'stun:stun2.l.google.com:19302',
        'stun:stun3.l.google.com:19302',
        'stun:stun4.l.google.com:19302',
      ],
    },
  ],
};

const App = () => {
  const [userId] = useState(Math.round(Math.random() * 1000000).toString());
  const [roomName, setRoomName] = useState(null);
  const [otherUserId, setOtherUserId] = useState(null);
  const [isJoined, setIsJoined] = useState(false);
  const [iceCandidatesGenerated, setIceCandidatesGenerated] = useState([]);
  const [iceCandidatesReceivedBuffer, setIceCandidatesReceivedBuffer] = useState(
    []
  );
  const [channelName, setChannelName] = useState('');
  const [message, setMessage] = useState('');
  const [answer, setAnswer] = useState(null);
  const [canISend, setCanISend] = useState(false);
  const [canISendIce, setCanISendIce] = useState(false);
  const pc = useRef(null);
  const dataChannel = useRef(null);
  const wsConnection = useRef(null);

  function handleClose() {
    console.log('You have been disconnected from our ws server');
  }

  function handleError() {
    console.log(
      'An error was thrown while listening on onerror event on websocket'
    );
  }

  useEffect(() => {
    if (isJoined === true && roomName !== null && otherUserId !== null) {
      startWebRTCProcess();
    }
  }, [otherUserId, roomName, isJoined]);

  useEffect(() => {
    console.log('IceCandidatesReceivedBuffer is updated.', iceCandidatesReceivedBuffer);
  }, [iceCandidatesReceivedBuffer]);

  useEffect(() => {
    console.log('All ICE candidates so far:', iceCandidatesGenerated);
  }, [iceCandidatesGenerated]);

  useEffect(() => {
    console.log('channleName is set');
  }, [channelName]);

  useEffect(() => {
    if (otherUserId !== null)
      console.log('otherUserId is:->', otherUserId);
  }, [otherUserId]);

  useEffect(() => {
    if (canISend === true) {
      sendAnswer(answer);
    }
  }, [canISend]);

  useEffect(() => {
    if (canISendIce === true) {
      console.log('Here is updated iceCandidatesGenerated array:-->', iceCandidatesGenerated);
      sendIceCandidates(iceCandidatesGenerated);
    }
  }, [canISendIce]);

  function joinSuccessHandler(data) {
    setOtherUserId(data.creatorId);
    setRoomName(data.roomName);
    setIsJoined(true);
  }

  function joinNotificationHandler(data) {
    Alert.alert(`User ${data.joinUserId} has joined your room`);
    setOtherUserId(data.joinUserId);
  }

  function updateUiForRemainingUser() {
    Alert.alert('A user has left your room');
    setOtherUserId(null);
  }

  function closePeerConnection() {
    if (pc.current) {
      pc.current.close();
      pc.current = null;
      dataChannel.current = null;
      console.log("You have closed your peer connection by calling the 'close()' method");
    }
  }

  function exitNotificationHandler(data) {
    updateUiForRemainingUser();
    closePeerConnection();
  }

  function normalServerProcessing(data) {
    switch (data.type) {
      case type.ROOM_JOIN.RESPONSE_SUCCESS:
        joinSuccessHandler(data);
        Alert.alert('Join room successful');
        break;
      case type.ROOM_JOIN.RESPONSE_FAILURE:
        console.log('join room failed');
        break;
      case type.ROOM_JOIN.NOTIFY:
        joinNotificationHandler(data);
        break;
      case type.ROOM_EXIT.NOTIFY:
        exitNotificationHandler(data);
        break;
      case type.ROOM_DISONNECTION.NOTIFY:
        exitNotificationHandler(data);
        break;
      default:
        console.log('unknown data type: ', data.type);
    }
  }

  const startWebRTCProcess = async () => {
    console.log("Teri Ma ki chu....");
    createPeerConnectionObject();
    createDataChannel(true);
  };
  const handleNegotiation = async ()=>{

    const offer = await pc.current.createOffer();
    await pc.current.setLocalDescription(offer);
    sendOffer(offer);
  }
  function createPeerConnectionObject() {
    pc.current = new RTCPeerConnection(webRTCConfiguratons);
    console.log(pc.current);
    pc.current.onconnectionstatechange = () => {
      console.log('connection state changed to: ', pc.current.connectionState);
      if (pc.current.connectionState === 'connected') {
        Alert.alert(
          'YOU HAVE DONE IT! A WEBRTC CONNECTION HAS BEEN MADE BETWEEN YOU AND THE OTHER PEER'
        );
      }
    };
    pc.current.onnegotiationneeded = ()=>{
      handleNegotiation();
    }
    pc.current.onsignalingstatechange = () => {
      console.log(`Signaling state changed to: ${pc.current.signalingState}`);
    };
    pc.onnego
    pc.current.onicecandidate = (e) => {
      if (e.candidate) {
        console.log('ICE:', e.candidate);
        setIceCandidatesGenerated((prev) => [...prev, e.candidate]);
      } else {
        setCanISendIce(true);
      }
    };
  }

  function createDataChannel(isOfferor) {
    if (isOfferor) {
      dataChannel.current = pc.current.createDataChannel(
        'top-secret-chat-room'
      );
      console.log("Here i am creating dataChannel:----->",dataChannel);
      registerDataChannelEventListeners();
    } else {
      pc.current.ondatachannel = (e) => {
        console.log('Data channel received:', e);
        dataChannel.current = e.channel;
        registerDataChannelEventListeners();
      };
    }
  }
  function registerDataChannelEventListeners() {
    dataChannel.current.onmessage = (e) => {
      console.log('message has been received from a Data Channel');
      const msg = e.data;
      console.log(msg);
    };
    dataChannel.current.onclose = (e) => {
      console.log("The 'close' event was fired on your data channel object");
    };
    dataChannel.current.onopen = (e) => {
      console.log(
        'Data Channel has been opened. You are now ready to send/receive messsages over your Data Channel'
      );
    };
  }

  function joinRoom(roomName, userId) {
    const message = {
      label: labels.NORMAL_SERVER_PROCESS,
      data: {
        type: type.ROOM_JOIN.REQUEST,
        roomName,
        userId,
      },
    };
    wsConnection.current.send(JSON.stringify(message));
  }

  function exitRoom(roomName, userId) {
    const message = {
      label: labels.NORMAL_SERVER_PROCESS,
      data: {
        type: type.ROOM_EXIT.REQUEST,
        roomName,
        userId,
      },
    };
    wsConnection.current.send(JSON.stringify(message));
  }

  function sendAnswer(answer) {
    console.log('Here i am sending answer to -->', otherUserId);
    const message = {
      label: labels.WEBRTC_PROCESS,
      data: {
        type: type.WEB_RTC.ANSWER,
        answer,
        otherUserId: otherUserId,
      },
    };
    wsConnection.current.send(JSON.stringify(message));
  }

  function sendOffer(offer) {
    const message = {
      label: labels.WEBRTC_PROCESS,
      data: {
        type: type.WEB_RTC.OFFER,
        offer,
        otherUserId: otherUserId,
      },
    };
    wsConnection.current.send(JSON.stringify(message));
  }

  function sendIceCandidates(arrayOfIceCandidates) {
    const message = {
      label: labels.WEBRTC_PROCESS,
      data: {
        type: type.WEB_RTC.ICE_CANDIDATES,
        candidatesArray: arrayOfIceCandidates,
        otherUserId: otherUserId,
      },
    };
    wsConnection.current.send(JSON.stringify(message));
  }

  async function handleOffer(data) {
    createPeerConnectionObject();
    createDataChannel(false);
    await pc.current.setRemoteDescription(data.offer);
    let currentAnswer = await pc.current.createAnswer();
    await pc.current.setLocalDescription(currentAnswer);
    setAnswer(currentAnswer);
    setCanISend(true);
  }

  async function handleAnswer(data) {
    await pc.current.setRemoteDescription(data.answer);
    for (const candidate of iceCandidatesReceivedBuffer) {
      await pc.current.addIceCandidate(new RTCIceCandidate(candidate));
    }
    setIceCandidatesReceivedBuffer([]);
  }

  function handleIceCandidates(data) {
    if (pc.current.remoteDescription) {
      try {
        data.candidatesArray.forEach((candidate) => {
          pc.current.addIceCandidate(new RTCIceCandidate(candidate));
        });
      } catch (error) {
        console.log('Error trying to add an ice candidate to the pc object', error);
      }
    } else {
      setIceCandidatesReceivedBuffer((prev) => [
        ...prev,
        ...data.candidatesArray.map((c) => c),
      ]);
    }
  }

  function webRTCServerProcessing(data) {
    switch (data.type) {
      case type.WEB_RTC.OFFER:
        handleOffer(data);
        break;
      case type.WEB_RTC.ANSWER:
        handleAnswer(data);
        console.log('Answer is received here it is:-->', data.answer);
        break;
      case type.WEB_RTC.ICE_CANDIDATES:
        console.log(
          'Ice candidates are received from other peer.You can see them here--->',
          data
        );
        handleIceCandidates(data);
        break;
      default:
        console.log('Unknown data type: ', data.type);
    }
  }

  function handleMessage(incomingMessageEventObject) {
    const message = JSON.parse(incomingMessageEventObject.data);
    console.log(message);
    switch (message.label) {
      case labels.NORMAL_SERVER_PROCESS:
        normalServerProcessing(message.data);
        break;
      case labels.WEBRTC_PROCESS:
        webRTCServerProcessing(message.data);
        break;
      default:
        console.log('unknown server processing label: ', message.label);
    }
  }

  function registerSocketEvents() {
    wsConnection.current.onopen = () => {
      console.log('You have connected with our websocket server');
      wsConnection.current.onmessage = handleMessage;
      wsConnection.current.onclose = handleClose;
      wsConnection.current.onerror = handleError;
    };
  }

  function websockethandler() {
    console.log('Hello');
    wsConnection.current = new WebSocket(`ws://10.0.2.2:8080/?userId=${userId}`); // Use 10.0.2.2 for Android emulator
    registerSocketEvents();
  }

  useEffect(() => {
    console.log('RoomName is set.');
  }, [roomName]);

  function createRoom(roomName, userId) {
    console.log('Here i have created roomName:->', roomName);
    fetch('http://10.0.2.2:8080/create-room', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ roomName, userId }),
    })
      .then((response) => response.json())
      .then((resObj) => {
        if (resObj.data.type === type.ROOM_CREATE.RESPONSE_SUCCESS) {
          setRoomName(roomName);
          Alert.alert('Room created successfully.');
        }
        if (resObj.data.type === type.ROOM_CREATE.RESPONSE_FAILURE) {
          console.log('Create Room Failure->', resObj.data.message);
        }
      })
      .catch((err) => {
        console.log('an error ocurred trying to create a room:-> ', err);
      });
  }

  function destroyRoom(roomName) {
    fetch('http://10.0.2.2:8080/destroy-room', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ roomName }),
    })
      .then((response) => response.json())
      .then((resObj) => {
        if (resObj.data.type === type.ROOM_DESTROY.RESPONSE_SUCCESS) {
          setRoomName(null);
          setOtherUserId(null);
        }
        if (resObj.data.type === type.ROOM_DESTROY.RESPONSE_FAILURE) {
          console.log(resObj.data.message);
        }
      })
      .catch((err) => {
        console.log('an error ocurred trying to destroy a room: ', err);
      });
  }

  function handleSendMessage(message) {
    dataChannel.current.send(message);
  }

  function handleExitRoom() {
    exitRoom(roomName, userId);
    setRoomName(null);
    setOtherUserId(null);
    closePeerConnection();
  }

  function handleJoinRoom() {
    if (!channelName) {
      return Alert.alert('You have to join a room with a valid name');
    }
    joinRoom(channelName, userId);
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>WebRTC Chat Room (User ID: {userId})</Text>
      <TextInput
        style={styles.input}
        placeholder="Enter room name"
        value={channelName}
        onChangeText={setChannelName}
      />
      {otherUserId !== null && (
        <Text style={styles.text}>Other User ID: {otherUserId}</Text>
      )}
      <View style={styles.buttonContainer}>
        <TouchableOpacity
          style={styles.button}
          onPress={() => createRoom(channelName, userId)}
        >
          <Text style={styles.buttonText}>Create Room</Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={styles.button}
          onPress={() => destroyRoom(channelName)}
        >
          <Text style={styles.buttonText}>Destroy Room</Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={styles.button}
          onPress={() => handleJoinRoom(roomName)}
        >
          <Text style={styles.buttonText}>Join Room</Text>
        </TouchableOpacity>
      </View>
      <View style={styles.buttonContainer}>
        <TouchableOpacity style={styles.button} onPress={() => handleExitRoom()}>
          <Text style={styles.buttonText}>Exit Room</Text>
        </TouchableOpacity>
        <TouchableOpacity style={styles.button} onPress={() => websockethandler()}>
          <Text style={styles.buttonText}>Start WebSocket</Text>
        </TouchableOpacity>
      </View>
      <TextInput
        style={styles.input}
        placeholder="Type a message..."
        value={message}
        onChangeText={setMessage}
      />
      <TouchableOpacity
        style={styles.button}
        onPress={() => handleSendMessage(message)}
      >
        <Text style={styles.buttonText}>Send</Text>
      </TouchableOpacity>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 20,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 10,
    marginBottom: 10,
    borderRadius: 5,
  },
  text: {
    fontSize: 16,
    marginBottom: 10,
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 10,
  },
  button: {
    backgroundColor: '#007AFF',
    padding: 10,
    borderRadius: 5,
    flex: 1,
    marginHorizontal: 5,
    alignItems: 'center',
  },
  buttonText: {
    color: '#fff',
    fontSize: 16,
  },
});

export default App;


// import React, { useRef, useState } from 'react';
// import { View, Button, StyleSheet } from 'react-native';
// import { RTCPeerConnection, RTCSessionDescription } from 'react-native-webrtc';

// const SERVER_URL = "ws://10.0.2.2:8080?userId=123";

// const App = () => {
//   const wsRef = useRef(null);
//   const peerRef = useRef(null);
//   const [connected, setConnected] = useState(false);

//   const connectWebSocket = () => {
//     wsRef.current = new WebSocket(SERVER_URL);

//     wsRef.current.onopen = () => {
//       console.log('WebSocket connected');
//       setConnected(true);
//     };

//     wsRef.current.onmessage = (event) => {
//       console.log('Received message:', event.data);
//     };

//     wsRef.current.onerror = (e) => {
//       console.log('WebSocket error:', e.message);
//     };

//     wsRef.current.onclose = () => {
//       console.log('WebSocket closed');
//       setConnected(false);
//     };
//   };

//   const createOfferAndSend = async () => {
//     peerRef.current = new RTCPeerConnection({
//       iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
//     });

//     peerRef.current.onicecandidate = (event) => {
//       if (event.candidate && wsRef.current?.readyState === 1) {
//         wsRef.current.send(JSON.stringify({
//           label: 'WEBRTC_PROCESS',
//           data: {
//             type: 'ICE_CANDIDATES',
//             candidate: event.candidate,
//             otherUserId: 456, // hardcoded target user for simplicity
//           }
//         }));
//       }
//     };

//     const offer = await peerRef.current.createOffer();
//     await peerRef.current.setLocalDescription(offer);

//     wsRef.current?.send(JSON.stringify({
//       label: 'WEBRTC_PROCESS',
//       data: {
//         type: 'OFFER',
//         sdp: offer,
//         otherUserId: 456, // hardcoded target user
//       }
//     }));

//     console.log('Offer created and sent to server');
//   };

//   return (
//     <View style={styles.container}>
//       <Button title="1. Connect WebSocket" onPress={connectWebSocket} />
//       <View style={{ marginVertical: 20 }} />
//       <Button
//         title="2. Create Peer & Send Offer"
//         onPress={createOfferAndSend}
//         disabled={!connected}
//       />
//     </View>
//   );
// };

// export default App;

// const styles = StyleSheet.create({
//   container: {
//     flex: 1,
//     justifyContent: 'center',
//     padding: 20
//   }
// });
